{"version":3,"file":"demo.min.js","sources":["../src/config.js","../src/enum.js","../src/index.js","../src/tools.js","../src/polyfill.js","../examples/index.js"],"sourcesContent":["export default {\n  recordable: true,\n  sampleRate: 16000,\n  sampleBits: 16,\n  bufferSize: 16384,\n};\n","export const RECORDER_STATE = {\n  READY: 0,\n  RECORDING: 1,\n};\n\nexport const ENCODE_TYPE = {\n  RAW: 'raw',\n  PCM: 'pcm',\n  WAV: 'wav',\n};\n","import {\n  merge,\n  compress,\n  encodeToPCM,\n  encodeToWAV,\n} from './tools';\nimport environmentCheck from './polyfill';\nimport DEFAULT_CONFIG from './config';\nimport { RECORDER_STATE, ENCODE_TYPE } from './enum';\n\nclass Recorderx {\n  state = RECORDER_STATE.READY\n\n  ctx = new (window.AudioContext || window.webkitAudioContext)()\n\n  sampleRate = DEFAULT_CONFIG.sampleRate\n\n  sampleBits = DEFAULT_CONFIG.sampleBits\n\n  recordable = DEFAULT_CONFIG.recordable\n\n  recorder = null\n\n  source = null\n\n  stream = null\n\n  buffer = []\n\n  bufferSize = 0\n\n  constructor (\n    {\n      recordable = DEFAULT_CONFIG.recordable,\n      bufferSize = DEFAULT_CONFIG.bufferSize,\n      sampleRate = DEFAULT_CONFIG.sampleRate,\n      sampleBits = DEFAULT_CONFIG.sampleBits,\n    } = DEFAULT_CONFIG,\n  ) {\n    const { ctx } = this;\n    const creator = ctx.createScriptProcessor || ctx.createJavaScriptNode;\n    this.recorder = creator.call(ctx, bufferSize, 1, 1);\n    this.recordable = recordable;\n    this.sampleRate = sampleRate;\n    this.sampleBits = sampleBits;\n  }\n\n  start (audioprocessCallback) {\n    this.ctx.resume();\n\n    return new Promise((resolve, reject) => {\n      navigator.mediaDevices\n        .getUserMedia({ audio: true })\n        .then((stream) => {\n          const { recorder } = this;\n          const source = this.ctx.createMediaStreamSource(stream);\n\n          this.stream = stream;\n          this.source = source;\n\n          recorder.onaudioprocess = (e) => {\n            const channelData = e.inputBuffer.getChannelData(0);\n\n            if (this.recordable) {\n              this.buffer.push(channelData.slice(0));\n              this.bufferSize += channelData.length;\n            }\n\n            if (typeof audioprocessCallback === 'function') {\n              audioprocessCallback(channelData);\n            }\n          };\n\n          source.connect(recorder);\n          recorder.connect(this.ctx.destination);\n\n          this.state = RECORDER_STATE.RECORDING;\n\n          resolve(stream);\n        })\n        .catch((error) => {\n          reject(error);\n        });\n    });\n  }\n\n  pause () {\n    this.stream.getAudioTracks()[0].stop();\n    this.recorder.disconnect();\n    this.source.disconnect();\n    this.ctx.suspend();\n    this.state = RECORDER_STATE.READY;\n  }\n\n  clear () {\n    this.buffer = [];\n    this.bufferSize = 0;\n  }\n\n  getRecord ({\n    encodeTo = ENCODE_TYPE.RAW,\n    compressible = false,\n  } = {\n    encodeTo: ENCODE_TYPE.RAW,\n    compressible: false,\n  }) {\n    if (this.recordable) {\n      let buffer = merge(this.buffer, this.bufferSize);\n\n      const inputSampleRate = this.ctx.sampleRate;\n      compressible = compressible && (this.sampleRate < inputSampleRate);\n      const outSampleRate = compressible ? this.sampleRate : inputSampleRate;\n\n      if (compressible) {\n        buffer = compress(buffer, inputSampleRate, outSampleRate);\n      }\n\n      switch (encodeTo) {\n        case ENCODE_TYPE.RAW:\n          return buffer;\n        case ENCODE_TYPE.PCM:\n          return encodeToPCM(buffer, this.sampleBits);\n        case ENCODE_TYPE.WAV:\n          return encodeToWAV(buffer, this.sampleBits, outSampleRate);\n        default:\n          throw new Error('Invalid parameter: \"encodeTo\" must be ENCODE_TYPE');\n      }\n    }\n\n    throw new Error('Configuration error: \"recordable\" must be set to true');\n  }\n}\n\nenvironmentCheck();\n\nexport const audioTools = {\n  merge,\n  compress,\n  encodeToPCM,\n  encodeToWAV,\n};\nexport { RECORDER_STATE, ENCODE_TYPE };\nexport default Recorderx;\n","export function merge (bufferList, length) {\n  const data = new Float32Array(length);\n\n  for (let i = 0, offset = 0; i < bufferList.length; offset += bufferList[i].length, i += 1) {\n    data.set(bufferList[i], offset);\n  }\n\n  return data;\n}\n\nexport function compress (buffer, inputSampleRate, outputSampleRate) {\n  if (inputSampleRate < outputSampleRate) {\n    throw new Error('Invalid parameter: \"inputSampleRate\" must be greater than \"outputSampleRate\"');\n  }\n\n  const bufferLength = buffer.length;\n  inputSampleRate += 0.0;\n  outputSampleRate += 0.0;\n  const compression = inputSampleRate / outputSampleRate;\n  const outLength = Math.ceil(bufferLength * outputSampleRate / inputSampleRate);\n  const data = new Float32Array(outLength);\n\n  let s = 0;\n  for (let i = 0; i < outLength; i += 1) {\n    data[i] = buffer[Math.floor(s)];\n    s += compression;\n  }\n\n  return data;\n}\n\nexport function encodeToPCM (bytes, sampleBits) {\n  if ([8, 16].indexOf(sampleBits) === -1) {\n    throw new Error('Invalid parameter: \"sampleBits\" must be 8 or 16');\n  }\n\n  const dataLength = bytes.length * (sampleBits / 8);\n  const buffer = new ArrayBuffer(dataLength);\n  const view = new DataView(buffer);\n\n  for (let i = 0, offset = 0; i < bytes.length; i += 1, offset += sampleBits / 8) {\n    const s = Math.max(-1, Math.min(1, bytes[i]));\n    const val = s < 0 ? s * 0x8000 : s * 0x7fff;\n    if (sampleBits === 8) {\n      view.setInt8(offset, parseInt(255 / (65535 / (val + 32768)), 10), true);\n    } else {\n      view.setInt16(offset, val, true);\n    }\n  }\n\n  return view.buffer;\n}\n\nexport function encodeToWAV (bytes, sampleBits, sampleRate) {\n  if ([8, 16].indexOf(sampleBits) === -1) {\n    throw new Error('Invalid parameter: \"sampleBits\" must be 8 or 16');\n  }\n\n  const dataLength = bytes.length * (sampleBits / 8);\n  const buffer = new ArrayBuffer(44 + dataLength);\n  const view = new DataView(buffer);\n  const channelCount = 1;\n  let offset = 0;\n\n  const writeString = (str) => {\n    for (let i = 0; i < str.length; i += 1) {\n      view.setUint8(offset + i, str.charCodeAt(i));\n    }\n  };\n\n  // WAV HEAD\n  writeString('RIFF');\n  offset += 4;\n  view.setUint32(offset, 36 + dataLength, true);\n  offset += 4;\n  writeString('WAVE');\n  offset += 4;\n  writeString('fmt ');\n  offset += 4;\n  view.setUint32(offset, 16, true);\n  offset += 4;\n  view.setUint16(offset, 1, true);\n  offset += 2;\n  view.setUint16(offset, channelCount, true);\n  offset += 2;\n  view.setUint32(offset, sampleRate, true);\n  offset += 4;\n  view.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), true);\n  offset += 4;\n  view.setUint16(offset, channelCount * (sampleBits / 8), true);\n  offset += 2;\n  view.setUint16(offset, sampleBits, true);\n  offset += 2;\n  writeString('data');\n  offset += 4;\n  view.setUint32(offset, dataLength, true);\n  offset += 4;\n\n  // write PCM\n  for (let i = 0; i < bytes.length; i += 1, offset += sampleBits / 8) {\n    const s = Math.max(-1, Math.min(1, bytes[i]));\n    const val = s < 0 ? s * 0x8000 : s * 0x7fff;\n\n    if (sampleBits === 8) {\n      view.setInt8(offset, parseInt(255 / (65535 / (val + 32768)), 10), true);\n    } else {\n      view.setInt16(offset, val, true);\n    }\n  }\n\n  return new Blob([view], { type: 'audio/wav' });\n}\n","export default function environmentCheck () {\n  if (window === undefined || navigator === undefined) {\n    return;\n  }\n\n  if (navigator.mediaDevices === undefined) {\n    navigator.mediaDevices = {};\n  }\n\n  if (navigator.mediaDevices.getUserMedia === undefined) {\n    navigator.mediaDevices.getUserMedia = (constraints) => {\n      const getUserMedia = navigator.getUserMedia\n        || navigator.webkitGetUserMedia\n        || navigator.mozGetUserMedia\n        || navigator.msGetUserMedia;\n\n      if (!getUserMedia) {\n        return Promise.reject(\n          new Error('getUserMedia is not implemented in this environment'),\n        );\n      }\n\n      return new Promise((resolve, reject) => {\n        getUserMedia.call(navigator, constraints, resolve, reject);\n      });\n    };\n  }\n}\n","import Recorderx, { RECORDER_STATE, ENCODE_TYPE } from '../src/index';\n\nconst btnStart = document.getElementById('btn-start');\nconst btnPause = document.getElementById('btn-pause');\nconst btnClear = document.getElementById('btn-clear');\nconst dlog = document.getElementById('log');\nconst audio = document.getElementById('audio');\n\nfunction pushLog (log, error = '') {\n  const xlog = `<span style=\"margin-right:8px\">\n           ${(new Date()).toLocaleString()}:\n         </span>\n         <span style=\"color:${error ? 'red' : 'blue'}\">\n           ${log} ${error}\n         </span>`;\n  const dl = document.createElement('div');\n  dl.innerHTML = xlog;\n  dlog.appendChild(dl);\n}\n\nlet rc;\n\nbtnStart.addEventListener('click', () => {\n  if (!rc) {\n    rc = new Recorderx({\n      recordable: true,\n      sampleRate: 16000,\n    });\n  }\n  if (rc.state === RECORDER_STATE.READY) {\n    rc.start()\n      .then(() => {\n        pushLog('start recording');\n      })\n      .catch((error) => {\n        pushLog('Recording failed.', error);\n      });\n  }\n});\n\nbtnPause.addEventListener('click', () => {\n  if (rc && rc.state === RECORDER_STATE.RECORDING) {\n    rc.pause();\n    audio.src = URL.createObjectURL(rc.getRecord({\n      encodeTo: ENCODE_TYPE.WAV,\n      compressible: true,\n    }));\n    pushLog('pause recording');\n  }\n});\n\nbtnClear.addEventListener('click', () => {\n  rc.clear();\n});\n"],"names":["recordable","sampleRate","sampleBits","bufferSize","RECORDER_STATE","ENCODE_TYPE","Recorderx","DEFAULT_CONFIG","window","AudioContext","webkitAudioContext","ctx","this","creator","createScriptProcessor","createJavaScriptNode","recorder","call","audioprocessCallback","resume","Promise","resolve","reject","navigator","mediaDevices","getUserMedia","audio","then","stream","_this","source","createMediaStreamSource","onaudioprocess","e","channelData","inputBuffer","getChannelData","buffer","push","slice","length","connect","destination","state","error","getAudioTracks","stop","disconnect","suspend","encodeTo","compressible","bufferList","data","Float32Array","i","offset","set","merge","inputSampleRate","outSampleRate","outputSampleRate","Error","bufferLength","compression","outLength","Math","ceil","s","floor","compress","bytes","indexOf","dataLength","ArrayBuffer","view","DataView","max","min","val","setInt8","parseInt","setInt16","encodeToPCM","writeString","str","setUint8","charCodeAt","setUint32","setUint16","Blob","type","encodeToWAV","undefined","constraints","webkitGetUserMedia","mozGetUserMedia","msGetUserMedia","rc","btnStart","document","getElementById","btnPause","btnClear","dlog","pushLog","log","xlog","Date","toLocaleString","dl","createElement","innerHTML","appendChild","addEventListener","start","pause","src","URL","createObjectURL","getRecord","clear"],"mappings":"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"}